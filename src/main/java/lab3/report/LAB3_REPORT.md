# Asymmetric Ciphers

### Course: Cryptography & Security
### Author: Afteni Daniela

----

## Theory

Asymmetric Cryptography (a.k.a. Public-Key Cryptography)deals with the encryption of plain text when having 2 keys, one being public and the other one private. The keys form a pair and despite being different they are related.

As the name implies, the public key is available to the public but the private one is available only to the authenticated recipients.

A popular use case of the asymmetric encryption is in SSL/TLS certificates along side symmetric encryption mechanisms. It is necessary to use both types of encryption because asymmetric ciphers are computationally expensive, so these are usually used for the communication initiation and key exchange, or sometimes called handshake. The messages after that are encrypted with symmetric ciphers.



## Objectives:

* Get familiar with the asymmetric cryptography mechanisms.

* Implement an example of an asymmetric cipher.

* As in the previous task, use a client class or test classes to showcase the execution of your programs.

## RSA (Rivest–Shamir–Adleman)

RSA (Rivest–Shamir–Adleman) is a public-key cryptosystem that is widely used for secure data transmission. It is also one of the oldest.

In a public-key cryptosystem, the encryption key is public and distinct from the decryption key, which is kept secret (private). An RSA user creates and publishes a public key based on two large prime numbers, along with an auxiliary value. The prime numbers are kept secret. Messages can be encrypted by anyone, via the public key, but can only be decoded by someone who knows the prime numbers.

The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the "factoring problem". Breaking RSA encryption is known as the RSA problem. Whether it is as difficult as the factoring problem is an open question. There are no published methods to defeat the system if a large enough key is used.

RSA is a relatively slow algorithm. Because of this, it is not commonly used to directly encrypt user data.

The RSA algorithm is named after those who invented it in 1978: Ron Rivest, Adi Shamir, and Leonard Adleman.


### Implementation description


The RSA algorithm ensures that the keys, in the above illustration, are as secure as possible. The following steps highlight how it works:

1. Generating the keys
    
    1.1 Select two large prime numbers, x and y The prime numbers need to be large so that they will be difficult for someone to figure out. 

    1.2 Calculate ``` n = x * y ```

    1.3 Calculate the totient function; ```phi(n) = (x-1)(y-1) ```

    1.4 Select an integer ```e```, such that ```e``` is co-prime to ```phi(n)```
      and 1 < ```e``` < ```phi(n)```. The pair of numbers ```(n,e)``` makes up the public key.
      Note: Two integers are co-prime if the only positive integer that divides them is 1.

    1.5 Calculate ```d``` such that ```e.d = 1 mod phi(n)```. ```d``` can be found using the extended euclidean algorithm. The pair ```(n,d)``` makes up the private key.

2. Encryption
   Given a plaintext ```P```, represented as a number, the ciphertext ```C``` is calculated as: ```C = (P^e) mod n```.

3. Decryption
   Using the private key ```(n,d)```, the plaintext can be found using: ```P = (C^d) mod n```

   

Explanation for key-generation algorithm

The key is generated by multiple steps, first of them being to find large primes p and q (2 random large prime numbers of specified bitlength). 
Then, there is needed to Compute n from p and q , because n is mod for private & public keys, n bit length is key length. There is as well represented the function to determine the N number, by multiplying the 2 prime numbers.

```
    // generateRandomPrimeNumber - method responsible for finding the prime numbers
    @Override
    public BigInteger generateRandomPrimeNumber(int bits) {
        Random randomInteger = new Random();
        BigInteger randomLargePrime = BigInteger.probablePrime(bits, randomInteger);
        return randomLargePrime;
    }

    // numberN - function to determine the N number, by multiplying the 2 prime numbers
    @Override
    public BigInteger numberN(BigInteger q, BigInteger p) {
        return q.multiply(p);

    }
```
After those 2 steps, it is required to calculate Phi(n), also named Euler's totient function, which is equal to the formula Phi(n) = (p-1)(q-1). The next is the function for determination if number E, that should correspond to some rules: 1 < e < Phi(n) and gcd(e,Phi) = 1. if to say that in other words it would be like generating e by finding a Phi such that they are co-primes gcd = 1, which needs as well and recursive implementation of Euclidian algorithm to find greatest common denominator.

```
   @Override
    public BigInteger calculatePhiofN(BigInteger q, BigInteger p) {
        BigInteger phiOfN = (q.subtract(BigInteger.ONE)).multiply(p.subtract(BigInteger.ONE));
        return phiOfN;
    }
    
    // calculateNumberE -function for determination if number E, that should correspond to some rules:
    //                                                                                                  1 < e < Phi(n)
    //                                                                                                  gcd(e,Phi) = 1
    @Override
    public BigInteger calculateNumberE(BigInteger phi) {
        Random rand = new Random();
        BigInteger e = new BigInteger(1024, rand);
        do {
            e = new BigInteger(1024, rand);
            while (e.min(phi).equals(phi)) {
                // while phi is smaller than e, look for a new e
                e = new BigInteger(1024, rand);
            }
        } while (!gcd(e, phi).equals(BigInteger.ONE));
        // if gcd(e,phi) isn't 1 then stay in loop
        return e;
    }
    
    // gcd - formula for calculation of the greatest common divisor between 2 numbers
    public static BigInteger gcd(BigInteger x, BigInteger y) {
        if (y.equals(BigInteger.ZERO)) {
            return x;
        } else {
            return gcd(y, x.mod(y));
        }
    }
```

The last step is the calculation of d where  d ≡ e^(-1) (mod Phi(n)). Recursive extended Euclidean algorithm, solves the identity ax + by = gcd(a,b) and finds the multiplicative inverse which is the solution to ax ≡ 1 (mod m), and at the end returns [d, p, q] where d = gcd(a,b) and ap + bq = d.

```
    // extendedEuclidAlgorithm - method implements the extended Euclidean algorithm
    @Override
    public BigInteger[] extendedEuclidAlgorithm(BigInteger x, BigInteger y) {
        if (y.equals(BigInteger.ZERO)) return new BigInteger[] {
                x, BigInteger.ONE, BigInteger.ZERO
        };
        BigInteger[] values = extendedEuclidAlgorithm(y, x.mod(y));
        BigInteger d = values[0];
        BigInteger p = values[2];
        BigInteger q = values[1].subtract(x.divide(y).multiply(values[2]));
        return new BigInteger[] { d, p, q };
    }
```

Encryption process, starts by taking a string and converting each character to an ASCII decimal value, then encrypting the ciphered plaintext.

```
    // convertMessageIntoASCIIvalue - function which returns the converted character of the message into an ASCII value
    public static BigInteger convertMessageIntoASCIIvalue(String message) {
        message = message.toUpperCase();
        String cipherString = "";
        int i = 0;
        while (i < message.length()) {
            int character = (int) message.charAt(i);
            cipherString = cipherString + character;
            i++;
        }
        BigInteger cipherBig = new BigInteger(String.valueOf(cipherString));
        return cipherBig;
    }
    
    @Override
    public BigInteger encrypt(BigInteger message, BigInteger e, BigInteger n) {
        return message.modPow(e, n);
    }
```

Decryption process, same as for encryption, starts with decrypting the encrypted plaintext and taking a the big integer that is ciphered and converts it back to plain text.

```
    // convertASCIIvalueIntoMessage - function which returns the ASCII value of the message into a character
    public static String convertASCIIvalueIntoMessage(BigInteger message) {
        String cipherString = message.toString();
        String output = "";
        int i = 0;
        while (i < cipherString.length()) {
            int temp = Integer.parseInt(cipherString.substring(i, i + 2));
            char character = (char) temp;
            output = output + character;
            i = i + 2;
        }
        return output;
    }
    
    @Override
    public BigInteger decrypt(BigInteger message, BigInteger d, BigInteger n) {
        return message.modPow(d, n);
    }
```

In main:

```
    // Rivest-Shamir-Adleman (RSA) Cipher
        final Cipher cipherRSA = new RivestShamirAdlemanRSACipher();
        String plaintext = "LABORATORY WORK ABOUT ASYMMETRIC CIPHERS";
        BigInteger p = cipherRSA.generateRandomPrimeNumber(512);
        BigInteger q = cipherRSA.generateRandomPrimeNumber(512);
        BigInteger n = cipherRSA.numberN(q, p);
        BigInteger phi = cipherRSA.calculatePhiofN(q, p);
        BigInteger e = cipherRSA.calculateNumberE(phi);
        BigInteger d = cipherRSA.extendedEuclidAlgorithm(e, phi)[1];
        BigInteger cipherMessage = ((RivestShamirAdlemanRSACipher) cipherRSA).convertMessageIntoASCIIvalue(plaintext);
        BigInteger encrypted = cipherRSA.encrypt(cipherMessage, e, n);
        BigInteger decrypted = cipherRSA.decrypt(encrypted, d, n);
        String restoredMessageAfterDecryption = ((RivestShamirAdlemanRSACipher) cipherRSA).convertASCIIvalueIntoMessage(decrypted);
        System.out.println(plaintext);
        System.out.println(encrypted);
        System.out.println(restoredMessageAfterDecryption);
```

Test:

```
    public class RivestShamirAdlemanRSACipherTest {

    private static final String TEST_MESSAGE = "HELLO WORLD";

    private final Cipher cipherRSA = new RivestShamirAdlemanRSACipher();

    @Test
    public void testCryptMessage() {
        BigInteger p = cipherRSA.generateRandomPrimeNumber(512);
        BigInteger q = cipherRSA.generateRandomPrimeNumber(512);
        BigInteger n = cipherRSA.numberN(p, q);
        BigInteger phi = cipherRSA.calculatePhiofN(p, q);
        BigInteger e = cipherRSA.calculateNumberE(phi);
        BigInteger d = cipherRSA.extendedEuclidAlgorithm(e, phi)[1];
        BigInteger cipherMessage = ((RivestShamirAdlemanRSACipher) cipherRSA).convertMessageIntoASCIIvalue(TEST_MESSAGE);
        BigInteger encrypted = cipherRSA.encrypt(cipherMessage, e, n);
        BigInteger decrypted = cipherRSA.decrypt(encrypted, d, n);
        String restoredMessageAfterDecryption = ((RivestShamirAdlemanRSACipher) cipherRSA).convertASCIIvalueIntoMessage(decrypted);
        final boolean areEqual = TEST_MESSAGE.equalsIgnoreCase(restoredMessageAfterDecryption);

        assertTrue(areEqual);
    }
}
```

## Conclusions 

The RSA algorithm (Rivest-Shamir-Adleman) is the basis of a cryptosystem, a suite of cryptographic algorithms that are used for specific security services or purposes, which enables public key encryption and is widely used to secure sensitive data, particularly when it is being sent over an insecure network such as the internet.

Public key cryptography, also known as asymmetric cryptography, uses two different but mathematically linked keys -- one public and one private. The public key can be shared with everyone, whereas the private key must be kept secret.

In RSA cryptography, both the public and the private keys can encrypt a message. The opposite key from the one used to encrypt a message is used to decrypt it. This attribute is one reason why RSA has become the most widely used asymmetric algorithm. It provides a method to assure the confidentiality, integrity, authenticity, and non-repudiation of electronic communications and data storage.

RSA security relies on the computational difficulty of factoring large integers. As computing power increases and more efficient factoring algorithms are discovered, the ability to factor larger and larger numbers also increases.
