# Web Authentication & Authorisation.

### Course: Cryptography & Security
### Author: Afteni Daniela

----

## Theory

Authentication & authorization are 2 of the main security goals of IT systems and should not be used interchangibly. Simply put, during authentication the system verifies the identity of a user or service, and during authorization the system checks the access rights, optionally based on a given user role.

    There are multiple types of authentication based on the implementation mechanism or the data provided by the user. Some usual ones would be the following:

* Based on credentials (Username/Password);
* Multi-Factor Authentication (2FA, MFA);
* Based on digital certificates;
* Based on biometrics;
* Based on tokens.

    Regarding authorization, the most popular mechanisms are the following:

* Role Based Access Control (RBAC): Base on the role of a user;
* Attribute Based Access Control (ABAC): Based on a characteristic/attribute of a user.


## Objectives:


1. Take what you have at the moment from previous laboratory works and put it in a web service / serveral web services.
2. Your services should have implemented basic authentication and MFA (the authentication factors of your choice).
3. Your web app needs to simulate user authorization and the way you authorise user is also a choice that needs to be done by you.
4. As services that your application could provide, you could use the classical ciphers. Basically the user would like to get access and use the classical ciphers, but they need to authenticate and be authorized.



## Authentication: Multi-Factor Authentication & Authorization: Role Based Access Control (RBAC): Base on the role of a user

Considering that the main idea or the implemented service is to use the classical ciphers, then we need firstly to establish the structure of the ciphers, having their keys, plaintexts and shifts:

```
//here are represented the structures of ciphers
type DataEncryptionStandardDES struct {
	Key  uint64 `json:"key"`
	Text uint64 `json:"text"`
}

type VigenereCipher struct {
	Key      string `json:"key"`
	Text     string `json:"text"`
	Alphabet string `json:"alphabet"`
}

type RivestCipherRC4 struct {
	Key  []byte `json:"key"`
	Text string `json:"text"`
}

type PlayfairCipher struct {
	Key  string `json:"key"`
	Text string `json:"text"`
}

type CaesarPermutationCipher struct {
	Shift    int    `json:"shift"`
	Text     string `json:"text"`
	Alphabet string `json:"alphabet"`
}

type RivestShamirAdlemanRSAcipher struct {
	Key  uint64   `json:"key"`
	Text []uint64 `json:"text"`
}
```
Then there is required to establish the second element of the service, which is the user. It, of course, will contain the most important elements, those being: e-mail, password and its role (those roles are one of those: user or admin):

```
type User struct {
	Email    string `json:"email"`
	Password []byte `json:"_"`
	Role     string `json:"role"`
}
```

Taking into account that we are creating the service, we need to create the interface for the user service, having some processes: finding a user, getting all the users, registration of a user and loging in of a user. These will be implemented in the next way:

```
// the interface for the user service, having some processes:
// finding a user
// getting all the users
// registration of a user
// loging in of a user
type UserService interface {
	Get(email string) (User, error)
	GetAll() ([]User, error)
	Register(transferData transferData.CreateUser) error
	Login(transferData transferData.CreateUser) (string, error)
}

```

For the service, it is required to start the process of listening and Serving, which needs to include GET and POST methods, so as to be able to do work with the above functions. For example process of getting the user's e-mail

```
// process of getting the e-mail
	routerGroup.GET("/users/:email", func(context *gin.Context) {
		email := context.Param("email")
		user, err := newUserService.Get(email)
		if err != nil {
			context.JSON(404, gin.H{"error": err.Error()})
			return
		}
		context.JSON(200, user)
	})
```

There are more steps that are implemented so as to be able to have this code working, for example is working with the data tranfer, after that comes verification of the one time password code based on user email address, and finally all the methods, especially the registration and loging in ones can be done by the user, one time password for Multi-Factor Authentication being generated by:

```
// method to generate the One Time Password, having given an e-mail
// corresponding to a specific e-mail we will set a One Time Password
func (oneTimePasswordService *OneTimePasswordService) Generate(email string) (string, error) {
	oneTimePassword := strconv.Itoa(200000 + rand.Intn(900000))
	oneTimePasswordService.oneTimePasswords[email] = oneTimePassword
	return oneTimePassword, nil
}
```

More specifically, for registering a user, firstly what we will do is to verify if this user already exists, after that we need to hash the password and save it in the database, for security. In case of loging in process, there will be required just to find and get the user form the database storage, continuing to compare the password from the database with the one corrently hashed, in case the password is right, then we generate a JSON Web Token and return it.


JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA. In this case JSON Web Token is signed using the HMAC algorithm.

```
// function for generating the JSON Web Token
func Generate(email, role string) (string, error) {
	mapClai := jwt.MapClaims{}
	mapClai["authorized"] = true
	mapClai["email"] = email
	mapClai["role"] = role
	mapClai["exp"] = time.Now().Add(12 * time.Hour).Unix()
	tok := jwt.NewWithClaims(jwt.SigningMethodHS256, mapClai)
	token, err := tok.SignedString([]byte(os.Getenv("SECRET")))
	if err != nil {
		return "", err
	}
	return token, nil
}
```

Then in the authorAuthen are placed functions for authentication and authorization.

```
// the process of authorization is implemented here
// it is done by checking if the user has the required role
// for the usage of the authorization in the authorAuthen, it will be required to add it to the route
func UserHasaSpecificRole(role string) gin.HandlerFunc {
	return func(context *gin.Context) {
		roleFromToken := context.GetString("role")
		if roleFromToken != role {
			context.Abort()
			return
		}
		context.Next()
	}
}

// the process of authentication is implemented here
// it is done by checking if the JSON Web Token is valid and extracting user e-mail and role and saves them in the request context
// for the usage of authentication in the authorAuthen, it will be required to add it to the route
func AuthenticationJwt() gin.HandlerFunc {
	return func(context *gin.Context) {
		email, role, err := token.ExtractEmailRole(context)
		if err != nil {
			context.Abort()
			return
		}
		context.Set("email", email)
		context.Set("role", role)
		context.Next()
	}
}

Finally, in the server we can do the authentication and authorization before the user can use the classical ciphers (encryption and decryption processes) by calling POST metods. An example being the decryption of playfair cipher: 

```
// after Authorization - what can a user do: decrypt the playfair Cipher
	author.POST("/playfairCipher12/decrypt", func(context *gin.Context) {
		var transferData transferData.PlayfairCipher
		if err := context.ShouldBindJSON(&transferData); err != nil {
			context.JSON(400, gin.H{"appeared error": err.Error()})
			return
		}
		plainText := playfairCipher12.Decrypt(transferData.Key, transferData.Text)
		transferData.Text = plainText
		context.JSON(200, transferData)
	})
```

## Conclusions 

While authentication and authorization are often used interchangeably, they are separate processes used to protect an organization from cyber-attacks. As data breaches continue to escalate in both frequency and scope, authentication and authorization are the first line of defense to prevent confidential data from falling into the wrong hands. As a result, strong authentication and authorization methods should be a critical part of every organization’s overall security strategy. In this service implementation it was secured by ulti-Factor Authentication and Role Based Access Control (RBAC): Base on the role of a user, using JSON Web Token JWT and HMAC stands for Hash-based Message Authentication Code.